#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
blind low complexity modulo latic distributed quantization
\end_layout

\begin_layout Author
Lior Israeli, Yuval Kochman
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
background
\end_layout

\begin_layout Subsection
2D modulo quantizer
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "modulo quantizer explain"

\end_inset

modulo operation return the reminder after division of two numbers.
 here we will prefer signed modulo, which preserves the sign of the data.
 at signed modulo we firstly add half modulo size to the data, then performing
 to modulo operation, then subtracting the half modulo size.
 at figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "flow_before_after_modulo"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we can see the data before and after the modulo in 2D space.
 green is the modulo edges, where the data folds.
 blue is data before modulo and red is after modulo.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/flow_before_after_modulo.png
	lyxscale 5
	width 10cm
	height 10cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
flow before after modulo
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "flow_before_after_modulo"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
sinogram transformation and angle estimation
\end_layout

\begin_layout Standard
known also as radon transformation.
 figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "sinogram example"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is an example for the transform.
 figure (a) shows the original data, which is highly correlated, and has
 been manipulated by modulo quantizer, as explained at section 
\begin_inset CommandInset ref
LatexCommand ref
reference "modulo quantizer explain"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 the red line in the figure shows the estimated angle of the data by the
 sinogram.
 figure (b) shows the sinogram transformation, which has the same dimenstions
 as the original data.
 the x axis of the sinogram present angle and y axis present distance from
 the axis origins.
 each pixel at the sinogram present angle and distance of a line at the
 orignal data, and the value of this pixel presents the sum of values at
 the original data that are under this given line.
 
\end_layout

\begin_layout Standard
the angle estimation by the sinogram is by finding angle that contains the
 max std value.
 figure (c) is std on all sinogram y axis values per x axis value.
 it's easy to see at figure (b) that the max value is at angle value of
 -11, and also that the std of all y values at angle -11, is the highest
 from all angles.
 
\end_layout

\begin_layout Standard
figure (d) shows all y values at anlge -11.
 it contains 3 local maximum that represent the folded line at the data
 domain.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/sinogram_example_data.png
	lyxscale 10
	width 5cm
	height 5cm
	keepAspectRatio

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
input data
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/sinogram_example_sinogram.png
	lyxscale 10
	width 5cm
	height 5cm

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
sinogram transform
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/sinogram_example_sinogram_std.png
	lyxscale 10
	width 5cm
	height 5cm

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
std per angle
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/sinogram_example_values_at_angle.png
	lyxscale 10
	width 5cm
	height 5cm

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
sinogram values at estimated angle
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
sinogram example
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sinogram example"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
problem statement
\end_layout

\begin_layout Standard
The problem scheme has 2 transmitters and 2 receivers.
 the receivers deliver the data to central unit for further process.
\end_layout

\begin_layout Standard
each transmitter gets non discrete data, then quantizing the data on finite
 latic with fixed number of bit.
 the quantizer size should be set from ahead.
\end_layout

\begin_layout Standard
the transmitters transmit data with high correlation, by covariance matrix
 that we explain later.
 if we had a case that the transmitters can communicate between each other,
 we could use simple scheme that one is transmits the data as is and the
 second will transmit only the delta from the first, or other compression
 methods, but in our case, the transmitters don't communicate, and we want
 to find scheme that will take the advantage of the correlation between
 the transmitters and compress the transmitted data.
\end_layout

\begin_layout Standard
the covariance between the transmitters randomized as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula $h=\text{\left[\begin{array}{c}
 a\\
 b 
\end{array}\right]},$
\end_inset

a,b ~N
\end_layout

\begin_layout Standard
\begin_inset Formula $cov=hh^{T}+I*\frac{1}{SNR}$
\end_inset


\end_layout

\begin_layout Standard
in the process of looking for solution, we also used some simpler cases,
 of taking only 1 transmitter and 1 receiver, and also a case that we already
 know the data covariance.
 some of methods that we tried, can only be applied on those simpler cases
 and not on the problem statement.
\end_layout

\begin_layout Section
methods
\end_layout

\begin_layout Standard
this section will present few approaches that we applied on the problem
 statement.
 some of them can be used only when the the covariance is already known.
\end_layout

\begin_layout Subsection
clipping
\end_layout

\begin_layout Standard
the most common approach is just to set fixed size of quantizer and clip
 higher or lower values to the nearest value at the quantizer.
 for example, if we take quantizer with values of -1, 0 and 1, we will quantize
 the value of -2.5 to -1 and the value of 2.2 to 1.
 this approace clearly does not take advatage of the correlation between
 the transimitters but is very easy to implement and will be our naive method
 that we will compare to.
\end_layout

\begin_layout Subsection
integer fourcing
\end_layout

\begin_layout Standard
this approach, taken from the article of Ori TODO, is approach for higher
 order of data (about 8 transmitters), and is based on modulo property of:
\end_layout

\begin_layout Standard
\begin_inset Formula $mod(i*mod(x))=mod(i*x),i\exists integers$
\end_inset


\end_layout

\begin_layout Standard
where i is an integer number.
\end_layout

\begin_layout Standard
this equation can also be at matrix form where x is the data matrix and
 i is square matrix with only integers.
 we will call the integer matrix A, and the data matrix D:
\end_layout

\begin_layout Standard
\begin_inset Formula $mod(A*mod(D))=mod(A*D)$
\end_inset


\end_layout

\begin_layout Standard
mod operation on matrix is applying modulo seperatedly on each element at
 the matrix.
 now by this approach, the transmitter is doing modulo by a size that is
 known from ahead.
 an example of 2 transmitters is shown at figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "flow_before_after_modulo"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 the receiver firstly multiply the data by the A matrix, then it's also
 applying modulo at the same size at the transmitter used.
 what we want is that that after 
\begin_inset Formula $A*mod(D)$
\end_inset

 we will get the output inside the modulo range so when we apply the receiver
 modulo, it will make no effect.
 what we get from this situation is that mathematically we do 
\begin_inset Formula $mod_{RX}(A*mod_{TX}(D))$
\end_inset

 which is equal to 
\begin_inset Formula $mod_{RX}(A*D)$
\end_inset

, meaning the transmitter modulo has no effect and we get the same data
 at the output of this transmitter and also at perfect transmitter with
 endless quantizer.
 we're looking for a case that after multipying by A we get all the data
 inside the modulo, so at this case, the receiver modulo is also taking
 no effect.
 what we eventually get is that after the receiver, we get 
\begin_inset Formula $A*D$
\end_inset

 and becasue we know A, we can multiply it in 
\begin_inset Formula $A^{-1}$
\end_inset

and recover the original 
\begin_inset Formula $D$
\end_inset

.
\end_layout

\begin_layout Subsection
maximum likelihood modulo
\end_layout

\begin_layout Standard
this approach is assuming we know the covariance matrix of the original
 data, and by that, the ML modulo will not match our problem statement.
 at this approach we have 2 transmitters and 2 receivers.
 the transmitter is doing modulo by known size as shown at figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "flow_before_after_modulo"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 what we get after the modulo, is data that is folded into the modulo space.
 when the data is highly correlated, the shape of it at 2 dimension is like
 narrow elipse, and when folding this elipse by using modulo, we will get
 the distribution as shown at picture TODO.
 at most cases, one can easely see that this new distribution can be reconstruct
 to the original distribution.
 let say that the max value at original data is no more than 5 times of
 the modulo size, it means that each x values has 5 optional original places
 that can be folded into this folded place.
 if we take 2 dimensions, each x,y coordinate, can be taken from 25 optional
 place.
 those 25 places are all combinations of 5 from x and 5 from y.
 after knowning this rule, we can calculate the cdf of each of those 25
 options and check which one of them is the most likely to be our folded
 case.
 we use cdf and not pdf because each value is presenting all the space next
 to it as this value is quantized value.
\end_layout

\begin_layout Subsection
sinogram modulo
\end_layout

\begin_layout Standard
this method is the next step of the ML modulo method.
 the sinogram modulo does not assume to know the covariance of the original
 data, and it's using some manipulations to reconstruct the original data.
 the main idea is that all the folded parts are originally laying on the
 same folded line, which is the main eigenvector of the original covariance.
 if we find this line, and we know how its beening folded, so we can check
 for each sample where is the nearest folded part of the line and reconstruct
 the data by this knowledge.
 
\end_layout

\begin_layout Standard
to simplify it more, we will use more intuitive approach - the output of
 the transmitter is shown at red color at figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "flow_before_after_modulo"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 we apply sinogram transform, as explained at section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sinogram example"
plural "false"
caps "false"
noprefix "false"

\end_inset

, and from the sinogram we will get a line that goes on the main axis of
 the data.
 next step is taking the square area of the transmitters output, duplicate
 it horisontally and vertically as shown at the left figure at figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "flow_before_after_rotation"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 one can clearly see that now we have the original data, but in exchange
 we need to filter out the all the non relevant duplications of the original
 data.
 each sample has multiple duplications, and the receiver need to pick the
 one that is the closes to the main axis of the sinogram.
\end_layout

\begin_layout Standard
let's sum the flow in short:
\end_layout

\begin_layout Enumerate
transmitters applying modulo on data.
\end_layout

\begin_layout Enumerate
receiver apply sinogram on pattern and extract angle of data main axis.
\end_layout

\begin_layout Enumerate
receiver gets the transmitters 2D pattern and duplicates it horisontally
 and vertically.
\end_layout

\begin_layout Enumerate
for each duplicated sample, the receiver picks the one that is the closest
 to the sinogram main axis.
\end_layout

\begin_layout Standard
for finding closest sample to main line, it's easier to rotate the data
 by the line angle and then to find the samples that has the lowest absulot
 y values.
 left figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "flow_before_after_rotation"
plural "false"
caps "false"
noprefix "false"

\end_inset

 present data before rotation, and right figure present after rotation.
 x marker at both figures present all duplications of some specific sample.
 green samples at the right figure are the chosent duplications that are
 the closest to x axis from all the sample options.
\end_layout

\begin_layout Standard
for picking number of duplications to use, we will recal that the data distribut
ion is normal, and we can take as much duplications that we want to enshure
 low probability of getting samples that has no duplication at the right
 place.
 here we took 2 modulo size at each direction, which gives use space of
 modulo size multiply in 2.5.
 by simulations, the best modulo size is TODO which results in TODO length
 in all directions.
 at normal distribuiton, this length equals TODO sigma, that has probability
 of TODO to happen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/flow_before_after_rotation.png
	lyxscale 5
	width 10cm
	height 5cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
flow before after rotation
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "flow_before_after_rotation"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
signed modulo vs.
 unsigned
\end_layout

\begin_layout Standard
we use signed modulo at two methods, at integer forcing and at sinogram.
 at both cases we cannot use unsigned modulo, each by its own reasons.
 
\end_layout

\begin_layout Standard
at integer forcing the condition for the equation 
\begin_inset Formula $mod(A*mod(D))=mod(A*D)$
\end_inset

 to happen is that all element at 
\begin_inset Formula $A*mod(D)$
\end_inset

 will be inside the modulo.
 this criteria cannot be happen if we have signed data, and the we use unsigned
 modulo.
\end_layout

\begin_layout Standard
at sinogram method we might find advantages of using unsigned, for example
 at figure TODO, we need the modulo size to be only half of the data spread,
 but when data folded into itself, we will not be able to recover the original
 place, and this will result in high MSE that will be to high and will shadow
 the other cases success.
\end_layout

\begin_layout Section
single dimension quantizer
\end_layout

\begin_layout Standard
when scheme has only 1 transmitter and 1 receiver, we have no additional
 data, and no additional correlation that we can take advantage on.
 the only thing that we can take from 1D case, is to check optimum size
 for clipping method.
 we do this by calculating integral of MSE for each bin at the quantizer,
 and summing all MSEs parts.
 we have 1 variable that does change, which is the bin size, and we find
 optimal size that will minimize our total MSE.
\end_layout

\begin_layout Standard
TODO write all cdf and erf math
\end_layout

\begin_layout Standard
\begin_inset Formula $integral:b+1+s,b+S,e^{-x^{2}}-b/2+s$
\end_inset

 
\end_layout

\begin_layout Section
simulations results
\end_layout

\begin_layout Standard
we simulated each method and checked for optimal quantizer size and mean
 MSE.
 at some methods the MSE had rare cases that had high MSE, that changed
 the mean MSE, so we simulated a mass of cases per method so the mean MSE
 will reflect also rare cases.
\end_layout

\begin_layout Section
figures sources
\end_layout

\begin_layout Standard
all figures are taken from code that is maintained on git at https://github.com/l
israel1/quants
\end_layout

\begin_layout Standard
figures 
\begin_inset CommandInset ref
LatexCommand ref
reference "flow_before_after_modulo"
plural "false"
caps "false"
noprefix "false"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "sinogram example"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "flow_before_after_rotation"
plural "false"
caps "false"
noprefix "false"

\end_inset

 are generated by 
\end_layout

\begin_layout Standard
code
\backslash
results
\backslash
modulo_vs_naive_2
\backslash
int_force
\backslash
jupyter_reports
\backslash
sinogram
\backslash
flow_example.ipynb
\end_layout

\end_body
\end_document
